"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[777],{80777:function(e,t,n){n.d(t,{coinbaseWallet:function(){return s},safe:function(){return l}});var i=n(44840),a=n(50552),r=n(2652),c=n(28716),o=n(2987);function s(e={}){let t,d,h,l,u,w,m,g,f;return"3"===e.version||e.headlessMode?(0,i.K)(i=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",rdns:"com.coinbase.wallet",type:s.type,async connect({chainId:e}={}){try{let t=await this.getProvider(),n=(await t.request({method:"eth_requestAccounts"})).map(e=>(0,r.K)(e));h||(h=this.onAccountsChanged.bind(this),t.on("accountsChanged",h)),l||(l=this.onChainChanged.bind(this),t.on("chainChanged",l)),u||(u=this.onDisconnect.bind(this),t.on("disconnect",u));let i=await this.getChainId();if(e&&i!==e){let t=await this.switchChain({chainId:e}).catch(e=>{if(e.code===c.ab.code)throw e;return{id:i}});i=t?.id??i}return{accounts:n,chainId:i}}catch(e){if(/(user closed modal|accounts received is empty|user denied account)/i.test(e.message))throw new c.ab(e);throw e}},async disconnect(){let e=await this.getProvider();h&&(e.removeListener("accountsChanged",h),h=void 0),l&&(e.removeListener("chainChanged",l),l=void 0),u&&(e.removeListener("disconnect",u),u=void 0),e.disconnect(),e.close()},async getAccounts(){let e=await this.getProvider();return(await e.request({method:"eth_accounts"})).map(e=>(0,r.K)(e))},async getChainId(){let e=await this.getProvider();return Number(await e.request({method:"eth_chainId"}))},async getProvider(){if(!d){t=new(await (async()=>{let{default:e}=await Promise.all([n.e(8554),n.e(9606)]).then(n.t.bind(n,88554,19));return"function"!=typeof e&&"function"==typeof e.default?e.default:e})())({...e,reloadOnDisconnect:!1});let a=t.walletExtension?.getChainId(),r=i.chains.find(t=>e.chainId?t.id===e.chainId:t.id===a)||i.chains[0],c=e.chainId||r?.id,o=e.jsonRpcUrl||r?.rpcUrls.default.http[0];d=t.makeWeb3Provider(o,c)}return d},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:t}){let n=i.chains.find(e=>e.id===t);if(!n)throw new c.x3(new a.X4);let r=await this.getProvider();try{return await r.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,o.eC)(n.id)}]}),n}catch(i){if(4902===i.code)try{let i,a;i=e?.blockExplorerUrls?e.blockExplorerUrls:n.blockExplorers?.default.url?[n.blockExplorers?.default.url]:[],a=e?.rpcUrls?.length?e.rpcUrls:[n.rpcUrls.default?.http[0]??""];let c={blockExplorerUrls:i,chainId:(0,o.eC)(t),chainName:e?.chainName??n.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??n.nativeCurrency,rpcUrls:a};return await r.request({method:"wallet_addEthereumChain",params:[c]}),n}catch(e){throw new c.ab(e)}throw new c.x3(i)}},onAccountsChanged(e){0===e.length?this.onDisconnect():i.emitter.emit("change",{accounts:e.map(e=>(0,r.K)(e))})},onChainChanged(e){let t=Number(e);i.emitter.emit("change",{chainId:t})},async onDisconnect(e){i.emitter.emit("disconnect");let t=await this.getProvider();h&&(t.removeListener("accountsChanged",h),h=void 0),l&&(t.removeListener("chainChanged",l),l=void 0),u&&(t.removeListener("disconnect",u),u=void 0)}})):(0,i.K)(t=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",rdns:"com.coinbase.wallet",type:s.type,async connect({chainId:e,...t}={}){try{let n=await this.getProvider(),i=(await n.request({method:"eth_requestAccounts",params:"instantOnboarding"in t&&t.instantOnboarding?[{onboarding:"instant"}]:[]})).map(e=>(0,r.K)(e));m||(m=this.onAccountsChanged.bind(this),n.on("accountsChanged",m)),g||(g=this.onChainChanged.bind(this),n.on("chainChanged",g)),f||(f=this.onDisconnect.bind(this),n.on("disconnect",f));let a=await this.getChainId();if(e&&a!==e){let t=await this.switchChain({chainId:e}).catch(e=>{if(e.code===c.ab.code)throw e;return{id:a}});a=t?.id??a}return{accounts:i,chainId:a}}catch(e){if(/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(e.message))throw new c.ab(e);throw e}},async disconnect(){let e=await this.getProvider();m&&(e.removeListener("accountsChanged",m),m=void 0),g&&(e.removeListener("chainChanged",g),g=void 0),f&&(e.removeListener("disconnect",f),f=void 0),e.disconnect(),e.close?.()},async getAccounts(){let e=await this.getProvider();return(await e.request({method:"eth_accounts"})).map(e=>(0,r.K)(e))},async getChainId(){let e=await this.getProvider();return Number(await e.request({method:"eth_chainId"}))},async getProvider(){if(!w){let i="string"==typeof e.preference?{options:e.preference}:{...e.preference,options:e.preference?.options??"all"},{createCoinbaseWalletSDK:a}=await Promise.all([n.e(6758),n.e(9175),n.e(1214)]).then(n.bind(n,31214));w=a({...e,appChainIds:t.chains.map(e=>e.id),preference:i}).getProvider()}return w},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:n}){let i=t.chains.find(e=>e.id===n);if(!i)throw new c.x3(new a.X4);let r=await this.getProvider();try{return await r.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,o.eC)(i.id)}]}),i}catch(t){if(4902===t.code)try{let t,a;t=e?.blockExplorerUrls?e.blockExplorerUrls:i.blockExplorers?.default.url?[i.blockExplorers?.default.url]:[],a=e?.rpcUrls?.length?e.rpcUrls:[i.rpcUrls.default?.http[0]??""];let c={blockExplorerUrls:t,chainId:(0,o.eC)(n),chainName:e?.chainName??i.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??i.nativeCurrency,rpcUrls:a};return await r.request({method:"wallet_addEthereumChain",params:[c]}),i}catch(e){throw new c.ab(e)}throw new c.x3(t)}},onAccountsChanged(e){0===e.length?this.onDisconnect():t.emitter.emit("change",{accounts:e.map(e=>(0,r.K)(e))})},onChainChanged(e){let n=Number(e);t.emitter.emit("change",{chainId:n})},async onDisconnect(e){t.emitter.emit("disconnect");let n=await this.getProvider();m&&(n.removeListener("accountsChanged",m),m=void 0),g&&(n.removeListener("chainChanged",g),g=void 0),f&&(n.removeListener("disconnect",f),f=void 0)}}))}s.type="coinbaseWallet";var d=n(31232),h=n(38201);function l(e={}){let t,a;let{shimDisconnect:c=!1}=e;return(0,i.K)(i=>({id:"safe",name:"Safe",type:l.type,async connect(){let e=await this.getProvider();if(!e)throw new d.M;let t=await this.getAccounts(),n=await this.getChainId();return a||(a=this.onDisconnect.bind(this),e.on("disconnect",a)),c&&await i.storage?.removeItem("safe.disconnected"),{accounts:t,chainId:n}},async disconnect(){let e=await this.getProvider();if(!e)throw new d.M;a&&(e.removeListener("disconnect",a),a=void 0),c&&await i.storage?.setItem("safe.disconnected",!0)},async getAccounts(){let e=await this.getProvider();if(!e)throw new d.M;return(await e.request({method:"eth_accounts"})).map(r.K)},async getProvider(){if("undefined"!=typeof window&&window?.parent!==window){if(!t){let{default:i}=await Promise.all([n.e(6758),n.e(4814),n.e(3664)]).then(n.bind(n,73664)),a=new i(e),r=await (0,h.F)(()=>a.safe.getInfo(),{timeout:e.unstable_getInfoTimeout??10});if(!r)throw Error("Could not load Safe information");t=new(await (async()=>{let e=await Promise.all([n.e(4814),n.e(9934)]).then(n.t.bind(n,39934,19));return"function"!=typeof e.SafeAppProvider&&"function"==typeof e.default.SafeAppProvider?e.default.SafeAppProvider:e.SafeAppProvider})())(r,a)}return t}},async getChainId(){let e=await this.getProvider();if(!e)throw new d.M;return Number(e.chainId)},async isAuthorized(){try{if(c&&await i.storage?.getItem("safe.disconnected"))return!1;return!!(await this.getAccounts()).length}catch{return!1}},onAccountsChanged(){},onChainChanged(){},onDisconnect(){i.emitter.emit("disconnect")}}))}l.type="safe"}}]);